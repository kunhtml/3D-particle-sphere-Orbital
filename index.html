<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <title>3D Orbital Dance – Spherical Orbits</title>
  <style>
    body{margin:0;overflow:hidden;background:#000}
    canvas{display:block}
  </style>
  <!-- Import map để trình duyệt resolve "three" -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.163/build/three.module.js",
      "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.163/examples/jsm/"
    }
  }
  </script>
</head>
<body>
<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
import { EffectComposer } from "three/examples/jsm/postprocessing/EffectComposer.js";
import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass.js";
import { UnrealBloomPass } from "three/examples/jsm/postprocessing/UnrealBloomPass.js";

// ---------- Scene & camera ----------
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, .1, 4000);
camera.position.set(0, 120, 450);

// ---------- Renderer ----------
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.toneMapping = THREE.ACESFilmicToneMapping;
document.body.appendChild(renderer.domElement);

// ---------- Post-processing (bloom) ----------
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
const bloom = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 1.2, 0.4, 0.85);
bloom.strength = 1.4;
composer.addPass(bloom);

// ---------- Controls ----------
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

// ---------- Lights ----------
scene.add(new THREE.AmbientLight(0xffffff, .6));
const dir = new THREE.DirectionalLight(0xffffff, 1.2);
dir.position.set(200, 300, 150);
scene.add(dir);

// ---------- Star‑field background ----------
const starGeo = new THREE.BufferGeometry();
const STAR_COUNT = 2000;
const starPos = new Float32Array(STAR_COUNT*3);
for(let i=0;i<STAR_COUNT;i++){
  const r = THREE.MathUtils.randFloat(800,1900);
  const theta = THREE.MathUtils.randFloat(0,Math.PI*2);
  const phi = THREE.MathUtils.randFloat(0,Math.PI);
  starPos[i*3]   = r*Math.sin(phi)*Math.cos(theta);
  starPos[i*3+1] = r*Math.cos(phi);
  starPos[i*3+2] = r*Math.sin(phi)*Math.sin(theta);
}
starGeo.setAttribute('position', new THREE.BufferAttribute(starPos,3));
scene.add(new THREE.Points(starGeo, new THREE.PointsMaterial({color:0xffffff,size:2,sizeAttenuation:true})));

// ---------- Central planet ----------
const planet = new THREE.Mesh(
  new THREE.SphereGeometry(40,64,64),
  new THREE.MeshStandardMaterial({map:new THREE.TextureLoader().load('https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg'), roughness:.7})
);
scene.add(planet);

// ---------- Satellites (spherical shell of independent circular orbits) ----------
const NUM_SATS = 400;
const ORBIT_MIN = 160;
const ORBIT_MAX = 260;
const satGeo = new THREE.SphereGeometry(4,8,8);
const satMat = new THREE.MeshBasicMaterial({color:0xffa500});
const sats = new THREE.InstancedMesh(satGeo, satMat, NUM_SATS);
scene.add(sats);

const dummy = new THREE.Object3D();
const thetaArr = new Float32Array(NUM_SATS);
const velArr   = new Float32Array(NUM_SATS);
const radiusArr= new Float32Array(NUM_SATS);
const quatArr  = [];// store Quaternion per satellite

const Y_AXIS = new THREE.Vector3(0,1,0);
for(let i=0;i<NUM_SATS;i++){
  thetaArr[i]  = THREE.MathUtils.randFloat(0, Math.PI*2);
  velArr[i]    = THREE.MathUtils.randFloat(15,45)*Math.PI/180; // rad/s
  radiusArr[i] = THREE.MathUtils.randFloat(ORBIT_MIN, ORBIT_MAX);

  // Random orbit normal (unit vector)
  let nx,ny,nz;
  do{
    nx = THREE.MathUtils.randFloatSpread(2);
    ny = THREE.MathUtils.randFloatSpread(2);
    nz = THREE.MathUtils.randFloatSpread(2);
  } while(nx*nx+ny*ny+nz*nz < 0.01); // avoid near‑zero
  const normal = new THREE.Vector3(nx,ny,nz).normalize();

  // Quaternion that rotates base plane (normal Y_AXIS) onto "normal"
  const q = new THREE.Quaternion().setFromUnitVectors(Y_AXIS, normal);
  quatArr.push(q);
}

// ---------- Resize ----------
addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
  composer.setSize(innerWidth, innerHeight);
});

// ---------- Animation loop ----------
let last = performance.now();
const baseVec = new THREE.Vector3();
function animate(now){
  const dt = (now - last)/1000; last = now;

  for(let i=0;i<NUM_SATS;i++){
    thetaArr[i] += velArr[i]*dt;
    // base vector on XZ plane (Y=0) before rotation
    baseVec.set(Math.cos(thetaArr[i]), 0, Math.sin(thetaArr[i])).multiplyScalar(radiusArr[i]);
    baseVec.applyQuaternion(quatArr[i]); // rotate into satellite's orbital plane

    dummy.position.copy(baseVec);
    dummy.updateMatrix();
    sats.setMatrixAt(i, dummy.matrix);
  }
  sats.instanceMatrix.needsUpdate = true;

  controls.update();
  composer.render();
  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);
</script>
</body>
</html>
