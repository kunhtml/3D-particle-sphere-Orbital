<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <title>3D Orbital Dance â€“ Minimal</title>
  <style>
    body{margin:0;overflow:hidden;background:#000}
    canvas{display:block}
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.163/build/three.module.js",
      "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.163/examples/jsm/"
    }
  }
  </script>
</head>
<body>
<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
import { EffectComposer } from "three/examples/jsm/postprocessing/EffectComposer.js";
import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass.js";
import { UnrealBloomPass } from "three/examples/jsm/postprocessing/UnrealBloomPass.js";
import { ShaderPass } from "three/examples/jsm/postprocessing/ShaderPass.js";
import { FXAAShader } from "three/examples/jsm/shaders/FXAAShader.js";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 4000);
camera.position.set(0, 100, 520);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.outputEncoding = THREE.sRGBEncoding;
document.body.appendChild(renderer.domElement);

const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
const bloomPass = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 0.7, 0.8, 0.1);
composer.addPass(bloomPass);
const fxaaPass = new ShaderPass(FXAAShader);
const pixelRatio = renderer.getPixelRatio();
fxaaPass.material.uniforms["resolution"].value.x = 1 / (innerWidth * pixelRatio);
fxaaPass.material.uniforms["resolution"].value.y = 1 / (innerHeight * pixelRatio);
composer.addPass(fxaaPass);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

scene.add(new THREE.AmbientLight(0xffffff, 0.5));

const sunGeo = new THREE.SphereGeometry(20, 32, 32);
const sunMat = new THREE.MeshBasicMaterial({ color: 0xffffff, toneMapped: false });
const sun = new THREE.Mesh(sunGeo, sunMat);
scene.add(sun);

const STAR_COUNT = 2500;
const starPos = new Float32Array(STAR_COUNT * 3);
for (let i = 0; i < STAR_COUNT; i++) {
  const r = THREE.MathUtils.randFloat(800, 1800);
  const phi = THREE.MathUtils.randFloat(0, Math.PI);
  const th = THREE.MathUtils.randFloat(0, Math.PI * 2);
  starPos[i * 3] = r * Math.sin(phi) * Math.cos(th);
  starPos[i * 3 + 1] = r * Math.cos(phi);
  starPos[i * 3 + 2] = r * Math.sin(phi) * Math.sin(th);
}
const starGeo = new THREE.BufferGeometry();
starGeo.setAttribute("position", new THREE.BufferAttribute(starPos, 3));
scene.add(
  new THREE.Points(
    starGeo,
    new THREE.PointsMaterial({ color: 0xffffff, size: 2, sizeAttenuation: true, opacity: 0.5, transparent: true, blending: THREE.AdditiveBlending })
  )
);

const PLANET_RADIUS = 100;
const PT_PER_LAT = 210;
const planetGeo = new THREE.BufferGeometry();
const pos = [];
const col = [];
for (let lat = 0; lat <= 180; lat += 1) {
  const th = THREE.MathUtils.degToRad(lat - 90);
  const cos = Math.cos(th);
  const sin = Math.sin(th);
  const pts = Math.max(5, PT_PER_LAT * Math.cos((th * Math.PI) / 2 / Math.PI + 0.5));
  for (let j = 0; j < pts; j++) {
    const phi = THREE.MathUtils.randFloat(0, Math.PI * 2);
    const x = PLANET_RADIUS * cos * Math.cos(phi);
    const y = PLANET_RADIUS * sin;
    const z = PLANET_RADIUS * cos * Math.sin(phi);
    pos.push(x, y, z);
    const h = 0.5 + 0.4 * (y / PLANET_RADIUS);
    const s = THREE.MathUtils.randFloat(0.6, 0.9);
    const l = THREE.MathUtils.randFloat(0.4, 0.6);
    const color = new THREE.Color().setHSL(h, s, l);
    col.push(color.r, color.g, color.b);
  }
}
planetGeo.setAttribute("position", new THREE.Float32BufferAttribute(pos, 3));
planetGeo.setAttribute("color", new THREE.Float32BufferAttribute(col, 3));
const planetPts = new THREE.Points(
  planetGeo,
  new THREE.PointsMaterial({ size: 2.2, vertexColors: true, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending })
);
scene.add(planetPts);

function createSpiral(radius, tiltDeg, pointCount, turns, amp) {
  const geo = new THREE.BufferGeometry();
  const arr = new Float32Array(pointCount * 3);
  for (let i = 0; i < pointCount; i++) {
    const t = (i / pointCount) * Math.PI * 2 * turns;
    const rNoise = THREE.MathUtils.randFloat(-12, 12);
    const curR = radius + rNoise + (i / pointCount) * 8;
    arr[i * 3] = curR * Math.cos(t);
    arr[i * 3 + 1] = amp * Math.sin(t) + THREE.MathUtils.randFloatSpread(6);
    arr[i * 3 + 2] = curR * Math.sin(t);
  }
  geo.setAttribute("position", new THREE.BufferAttribute(arr, 3));
  const mat = new THREE.PointsMaterial({ size: 1.8, color: 0x8888ff, transparent: true, opacity: 0.4, blending: THREE.AdditiveBlending, sizeAttenuation: true });
  const spiral = new THREE.Points(geo, mat);
  spiral.rotation.x = THREE.MathUtils.degToRad(tiltDeg);
  return spiral;
}

const spiral1 = createSpiral(170, 18, 40000, 2.2, 10);
const spiral2 = createSpiral(195, -22, 40000, 2.5, 12);
scene.add(spiral1, spiral2);

let last = performance.now();
function animate(now) {
  const dt = (now - last) / 1000;
  last = now;
  spiral1.rotation.y += 0.06 * dt;
  spiral2.rotation.y -= 0.05 * dt;
  planetPts.rotation.y += 0.02 * dt;
  controls.update();
  composer.render();
  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

addEventListener("resize", () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
  composer.setSize(innerWidth, innerHeight);
  const pixelRatio = renderer.getPixelRatio();
  fxaaPass.material.uniforms["resolution"].value.x = 1 / (innerWidth * pixelRatio);
  fxaaPass.material.uniforms["resolution"].value.y = 1 / (innerHeight * pixelRatio);
  bloomPass.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
